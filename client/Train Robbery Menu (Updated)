#!/usr/bin/env python3
"""
train_menu.py
Main menu for the Train Carts (educational simulations only).
Compatible with your bash wrapper: make sure this file is executable.
"""

import sys
import subprocess
import shutil
import textwrap
from pathlib import Path

ROOM_SCRIPTS = {
    "1": "cart-1.c", #Buffer Overflow Training Exercise
    "2": "ddos_room.py",
}

EXPLAINERS = {
    "2": {
        "title": "Cart 2, the cargo hold: Buffer Overflow",
        "body": textwrap.dedent("""
        WHAT IT IS (high-level)
        -----------------------
        A buffer overflow is a programming error where more data is written to a
        fixed-size buffer than it can hold. In low-level languages this can
        overwrite adjacent memory and cause crashes or unexpected behavior.

        HOW IT WORKS (conceptual)
        -------------------------
        - Programs allocate memory for buffers.
        - If code copies unchecked input into a buffer larger than its capacity,
          neighboring memory can be corrupted.
        - This description is intentionally abstract and non-actionable.

        COMMON INDICATORS (defensive signals)
        ------------------------------------
        - Program crashes on unusual input.
        - Corrupted data or unexpected behavior after certain long inputs.
        - Logs showing overly long or malformed inputs.

        TRAINING EXERCISE SUMMARY
        ------------------
        - [Insert Later]
        """)
    },
    "1": {
        "title": "Cart 1, the engine room: DDoS",
        "body": textwrap.dedent("""
        WHAT IT IS (high-level)
        -----------------------
        A Distributed Denial of Service (DDoS) occurs when a target receives so
        much traffic or usage that legitimate users cannot access the service.

        HOW IT WORKS (conceptual)
        -------------------------
        - High volume or resource-intensive requests can saturate bandwidth,
          exhaust connection pools, or tie up server resources.
        - Sources may be many distributed machines or concentrated bursts.
        - This explanation is intentionally conceptual only.

        TRAINING EXERCISE SUMMARY
        ------------------------------------
        - [Insert Later]
        """)
    },
    "h": {
        "title": "Cart 2: DDoS",
        "body": textwrap.dedent("""
        links to articles, progression
        """)
    },
    "i": {
        "title": "Cart 2: DDoS",
        "body": textwrap.dedent("""
        proc maps and other info about the train
        """)
    }
}


def clear():
    # simple cross-platform clear
    import os
    os.system('cls' if os.name == 'nt' else 'clear')

def print_header():
    print("="*60)
    print(" TRAIN - Intrusion Review (EDUCATIONAL SIMULATIONS ONLY)")
    print(" NOTE: These carts are defensive/educational. No exploit code.")
    print("="*60)
    print()

def show_menu():
    print("Choose a room to enter:")
    print(" 1) DDoS (traffic simulation & mitigation exercise)")
    print(" 2) Buffer Overflow (safe simulation & basic intrusion exercise)")
    print(" h) Help")
    print(" t) Tools & info")
    print(" q) Quit")
    print()

ROOM_SCRIPTS = {
    "1": "ddos_room.py",        # shell script
    "2": "cart-1.sh",     # python script
    "3": ["bash", "-c", "echo 'ad-hoc command'; sleep 1"],  # arbitrary command
}

def run_room(script):
    """
    script may be:
      - a string path (relative or absolute) to a file
      - a list/tuple of command tokens (runs directly)
    Behavior:
      - If argument is command sequence: run it directly.
      - If argument is a path:
          - if executable -> run it (OS will use shebang)
          - elif extension .sh -> run with bash
          - elif extension .py -> run with python interpreter
          - else -> attempt to run with /bin/sh
    Returns subprocess.CompletedProcess
    """
    # If caller passed a command sequence (list/tuple), run it directly.
    if isinstance(script, (list, tuple)):
        cmd = list(script)
        print(f"[run_room] Running command: {cmd}")
        return subprocess.run(cmd)

    # treat as a string path
    path = Path(script)
    if not path.exists():
        print(f"[run_room] ERROR: {path} not found.")
        return None

    # If file is executable, run it directly (uses shebang)
    if os.access(path, os.X_OK):
        cmd = [str(path)]
        print(f"[run_room] Executing executable: {cmd}")
        return subprocess.run(cmd)

    # Not executable: use heuristics by suffix
    suffix = path.suffix.lower()
    python_exec = shutil.which("python3") or shutil.which("python") or sys.executable

    if suffix == ".py":
        cmd = [python_exec, str(path)]
        print(f"[run_room] Running Python file: {cmd}")
        return subprocess.run(cmd)
    elif suffix == ".sh":
        # prefer bash; fallback to /bin/sh
        bash = shutil.which("bash") or "/bin/sh"
        cmd = [bash, str(path)]
        print(f"[run_room] Running shell script with: {cmd}")
        return subprocess.run(cmd)
    else:
        # last resort: run via /bin/sh
        cmd = ["/bin/sh", str(path)]
        print(f"[run_room] Unknown extension; running with sh: {cmd}")
        return subprocess.run(cmd)

def show_help():
    print("\nHELP â€” How to use the Train Carts (educational only):")
    print(" - Select a cart number to launch the training program.")
    print(" - Each cart is a safe simulation that teaches defensive concepts.")
    print(" - Do NOT attempt to use these programs against any real system.")
    print(" - For ethical practice, use legal CTF platforms and isolated labs.\n")

def main():
    clear()
    print_header()
    while True:
        show_menu()
        choice = input("Enter choice: ").strip().lower()
        if choice in ROOM_SCRIPTS:
            # Show the explainer for the chosen room (if available) so the user
            # can read the conceptual/defensive guidance before entering.
            expl = EXPLAINERS.get(choice)
            if expl:
                print(f"\n=== {expl['title']} ===\n")
                print(expl['body'])
                input("\nPress Enter to launch the room (or Ctrl-C to cancel)...")

            result = run_room(ROOM_SCRIPTS[choice])
            if result is None:
                print("Failed to start room.")
            else:
            # result is a CompletedProcess; check exit code
                rc = result.returncode
                print(f"Room exited with code {rc}.")
            input("\nPress Enter to return to the train menu...")
            clear()
            print_header()
        elif choice == 'h' or choice == 'help':
            show_help()
            input("\nPress Enter to return to the train menu...")
            clear()
            print_header()
        elif choice == 't' or choice == 'tools':
            show_help()
            input("\nPress Enter to return to the train menu...")
            clear()
            print_header()
        elif choice == 'q' or choice == 'quit' or choice == 'exit':
            print("Exiting. Stay safe and ethical.")
            break
        else:
            print("Invalid choice. Enter 1, 2, h, t, or q.\n")

if __name__ == "__main__":
    main()
