echo -e "Lets look at buffer overflow and our tool to use.\nThe idea of a buffer overflow is writing more data than what a buffer is allocated for\n"
sleep 5
echo -e "For example, looking at the following code, we see a potential issue: 


char buffer[200];
 if (gets(buffer) != 0) {
        printf("Received: %s\n", buffer);
        send(new_socket, buffer, strlen(buffer), 0);
    }

gets does not check for out of bounds writing, 
meaning that data can be overwritten in the stack."

sleep 10

echo -e "\n\nThis is bad beacuse return addresses, values used to figure out 
what programs to execute, can be purposefully overwritten
If I replace a return address with my own, I can execute whatever I want"

sleep 20

echo -e "\n\nImagine if I input code that would give me a shell, 
then replaced the return address with my own
the structure of our egg, generated by our tool ovf, is as follows"

echo "
 *          NOP slide
 *          Shell code
 *          Address Block
 * 
 * The Address Block must be aligned on a long long boundary and hence
 * the shell code length is hard-coded so that the user is very aware 
 * of the shell code length in order to attempt proper alignment. The 
 * NOP slide length can be adjusted to vary the alignment.
*/"

sleep 30

echo -e "\n\nLet's walk through the process, explaining on the way.
First, I want to figure out how big the buffer of the program is,
so I can use echo \$(perl -e 'print "A" x370') | nc -vv -w 10 127.0.0.1 61
to see if the program crashes or not. I want to do a binary search to find
the exact value of bytes the program crashes at, so If I determine the program is
100 bytes, I will specify 100-48 bytes(how long our shellcode is) meaning we will
have 52 nops. Thats one parameter down.\n\n"

sleep 20

echo -e "\n\nThe next two are easy, being the amount of return addresses and the base of the
stack. I want a good amount of return addresses, but not to much to where I am crashing
the program anywhere from 2 to 20. The next is the stack base, which we need to know to give
a correct return address to our shellcode. If I cat /proc/pid/maps, 
I will see the bottom address
but in info, this information is given. Simply find the highest address mapped to the stack."

sleep 20

echo -e "\n\nLastly, the offset. The offset can be any value 0 to 100000, 
so I have to binary search for the correct value. 
The offset is more commonly lower than not, but using output from the program I can narrow 
onto the correct offset. 
Because I do not know where my program is going to be stored, I esentially am guessing
where my program is on the stack. To high of an offset, and I am giving a return address 
that does not point to any code, and to little, 
I am writing to unmapped memory out of the stack"

sleep 20

echo -e "Try using this tool by using 
./ovf <NOP slide length> <address block length> <stack address> <offset> > egg, replacing the values of the parameters
then run cat egg | nc 127.0.0.1 61 (or 101 against the main cart), and if successful no errors will return."

sleep 20;

echo -e "\n\nFor the main train, if successful you will get no errors, and at this point, run
nc 127.0.0.1 101 by itself, at which point you can search for the flag\n
Try against the training train, which will give more clues as to the harder actual cart
Happy Hacking!"
